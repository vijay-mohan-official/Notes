SpringBoot Notes
Spring Boot is a framework for building applications in Java programming language.
Spring Boot makes it easy to create standalone production-grade Spring-based applications that you can just run.

We need to manually set up application context in the main method in a Spring application.
We use the @SpringBootApplication annotation on the main class.
This single annotation replaces the need for setting up manual Spring application context.
We no longer need to explicitly create an application context using annotation config application context as SpringBoot handles that behind the scenes. 

We use SpringApplication.run() to start the application, and Spring Boot takes care of configuring the embedded web server and other necessary components. 
The @SpringBootApplication annotation alone brings in a lot of pre-configured features including automatic component scanning and embedded server configuration, which would have required more steps in a traditional Spring setup. 

JAR - Java Archive (Can be simply run from CLI)
WAR - Web Application Archive (Should be deployed on a Web server)

To check the process ID or application running on your system :
tasklist /FI "PID eq <Process-ID>"

Maven - Build automation tool
		Dependency management tool
		
pom.xml - Project Object Model.xml

Maven Lifecycle : validate > compile > test > package > verify > install > deploy
validate - Checks if everything is written correctly in pom.xml
compile - Compile source code to target folder
test - Tests you app, if there are any tests written
package - Creates jar in target folder
install - Install the jar in you m2 local repository
deploy - To copy jar to a remote repository

clean - To remove everything in target folder

If Maven is not installed, we can use Maven wrapper provided by SpringBoot :
mvn validate is used to validate a project if mvn is installed in your system
When using Maven wrapper, we use command
./mvnw validate

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
Used to compare the pom.xml file and ensure that it is well formatted and can be correctly intepretted by Maven.

<properties>
		<java.version>1.8</java.version>
</properties>
The reason why we specify java version inside properties is to override maven plugin and let it know that the byte code generated should be compatible with version specified.

When we package or install an application, two jars are created :
<project-name>.jar - Contains all the compiled classes, resources, and dependencies packaged together, allowing you to run your application easily using the java -jar command.(FAT jar)
<project-name>.jar.original - Represent the original state of the JAR before modifications or optimizations were applied.

SpringBoot Maven plugin initially creates the .jar.original file and then repackages with all the dependencies.

In Java to create an object of a class, we use new operator :
Car car = new Car();

In SpringBoot we are externalizing the object creation part and is asking SpringBoot to create an object and give it to me in the class. 
This concept is called Inversion of Control(IOC).
We got to the IOC container and ask SpringBoot to create the object for me.
IOC Container has all the classes that are part of your SpringBoot project.
ApplicationContext is a way to implement IOC Container.

IOC Container won't store all the classes, it stored spatial classes, i.e classes with @Component annotation.
@Component annotation can be written over classes, interfaces, methods and even fields.
@Component will automically register the component(class/interface etc) as a Spring Bean and store in IOC container.(Bean ==> Object in Spring)

@SpringBootApplication is written over the main method class in a SpringBoot project.
Only one class will have @SpringBootApplication annotation in a project.
@SpringBootApplication performs three tasks : 
	@Configuration - If @Configuration is written over any class, Spring will know that class has declared multiple @Bean methods
	@EnableAutoConfiguration - Automatically use properties specified in properties.(If MongpDB is used and port, server, username, password etc is specified in properties file, Spring will automically configure and connect the DB for you)
	@ComponentScan - Scan for classes with @Component annotation under the base package.(Package which has class with @SpringBootApplication annotation)

@Autowired annotation is used for Dependency Injection.
We ask Spring to return an object stored in IOC container.

Spring Initializr - spring.io is used to set up a simple SpringBoot project with necessary dependencies
Group - com.<company-name>  : Used to specify company name which is developing the application in reverse domain fashion
Artifact : Used to specify the name of application that we are going to create.(Start with small letter)
Name : Name of application in human readable format
Description : Details of application that we are creating
Package Name : Group.Artifact

REST-API
REST : Representational State Transfer(Representational == > Client and Server and in b/w we transfer data)
API : Application Programming Interfaces
Used to communicate with an application running on a server.
Communication happens through a URL call to an API exposed by the application.
URL : 172.67.23.24:8080
Endpoint : 172.67.23.24:8080/ntfx/plans
REST-API : GET/POST/PUT/DELETE + 172.67.23.24:8080/ntfx/plans

To access the endpoint you need to add HTTP verb.
HTTP verbs are of 4 types :
	GET - To fetch and see some data. (To see data in DB)
	POST - To create something. (To create an entry in DB)
	PUT - To modify something. (To modify an entry in DB)
	DELETE - To delete something. (To delete an entry from DB)
	
@RestController - Annotation used to specify a component through which API calls enter the application.

@GetMapping - Used to map a function to an endpoint which uses GET verb and that returns some data.

@RequestMapping - Used to add an new mapping to the whole class(additional path to differentiate controllers).

Methods written inside a Controller class should be public so that they can be accessed and invoked by Spring framework or external HTTP requests.

@RequestBody - Asking Spring to take the data from the request and convert into a java object that we can use in code 







Response Entity is part of the Spring Framework and is commonly used in SpringBoot applications to customize the HTTP response.
It provides methods for setting the response status, headers and body.
You can use it to return different types of data in your controller methods, such as JSON, XML or even HTML.
You can use Generics with Response Entity to specify the type of data you are returning.

Lombok Library
Lombok is a popular library in the Java ecosystem, often used in SpringBoot applications.
It aims to reduce the boilerplate code that developers have to write such as getters, setters, constructors etc.
