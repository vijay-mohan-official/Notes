In Java to create an object of a class, we use new operator :
Car car = new Car();

In SpringBoot we are externalizing the object creation part and is asking SpringBoot to create an object and give it to me in the class. 
This concept is called Inversion of Control(IOC).
We got to the IOC container and ask SpringBoot to create the object for me.
IOC Container has all the classes that are part of your SpringBoot project.
ApplicationContext is a way to implement IOC Container.

IOC Container won't store all the classes, it stored spatial classes, i.e classes with @Component annotation.
@Component annotation can be written over classes, interfaces, methods and even fields.
@Component will automically register the component(class/interface etc) as a Spring Bean and store in IOC container.(Bean ==> Object in Spring)

@SpringBootApplication is written over the main method class in a SpringBoot project.
Only one class will have @SpringBootApplication annotation in a project.
@SpringBootApplication performs three tasks : 
	@Configuration - If @Configuration is written over any class, Spring will know that class has declared multiple @Bean methods
	@EnableAutoConfiguration - Automatically use properties specified in properties.(If MongpDB is used and port, server, username, password etc is specified in properties file, Spring will automically configure and connect the DB for you)
	@ComponentScan - Scan for classes with @Component annotation under the base package.(Package which has class with @SpringBootApplication annotation)

@Autowired annotation is used for Dependency Injection.
We ask Spring to return an object stored in IOC container.

Spring Initializr - spring.io is used to set up a simple SpringBoot project with necessary dependencies
Group - com.<company-name>  : Used to specify company name which is developing the application in reverse domain fashion
Artifact : Used to specify the name of application that we are going to create.(Start with small letter)
Name : Name of application in human readable format
Description : Details of application that we are creating
Package Name : Group.Artifact

REST-API
REST : Representational State Transfer(Representational == > Client and Server and in b/w we transfer data)
API : Application Programming Interfaces
Used to communicate with an application running on a server.
Communication happens through a URL call to an API exposed by the application.
URL : 172.67.23.24:8080
Endpoint : 172.67.23.24:8080/ntfx/plans
REST-API : GET/POST/PUT/DELETE + 172.67.23.24:8080/ntfx/plans

To access the endpoint you need to add HTTP verb.
HTTP verbs are of 4 types :
	GET - To fetch and see some data. (To see data in DB)
	POST - To create something. (To create an entry in DB)
	PUT - To modify something. (To modify an entry in DB)
	DELETE - To delete something. (To delete an entry from DB)
	
@RestController - Annotation used to specify a component through which API calls enter the application.

@GetMapping - Used to map a function to an endpoint which uses GET verb and that returns some data.

@RequestMapping - Used to add an new mapping to the whole class(additional path to differentiate controllers).

Methods written inside a Controller class should be public so that they can be accessed and invoked by Spring framework or external HTTP requests.

@RequestBody - Asking Spring to take the data from the request and convert into a java object that we can use in code 