Time & Space Complexity
Suppose you have a problem 'P' and there are three algorithms, A1,A2,A3 to solve P. So how to decide which algorithm to choose? 
That's where time and space complexity comes.

An algorithm is a technique used to solve a given problem.

Time complexity refers to the time taken by an algorithm.
Space complexity refers to the space utilized by an algorithm.

We choose an algorithm which takes lesser time and space complexities.

Types of cases
Given below is an algorithm for linear search.
linearSearch(arr, n) {
  for(i=0; i< arr.length; i++){
    if(arr[i] == n){
      return true;
    }
  }
  return false;
}

Each algorithm has three cases :
1) Best
2) Worst
3) Average

Suppose we have an array [3,2,1,9,7]
When using linear search, best case in this array to search for 3, worst for 7 and average case for 1.

The worst case is the most important case as it is the most time consuming one.
In case of developing an API, we should always mention the worst case to the client, never the best case. Best case time < Worst case time.




Asymptotic Notation
Asymptotic notation is a way of denoting time complexity of algorithms.

There are 3 types of asymptotic notations:
1) Theta Notation(θ)
2) Big O Notation(O)
3) Omega Notation(Ω)

Suppose I have an algorithm,
f(n) = cn^3 + dn^2 + en + f

In the above algorithm, the most dependent term is cn^3, if n = 1000,
cn^3 = 1000000000c
==> we can neglect other terms dn^2, en, f

Hence we can say that the order of growth of the algorithm is n^3, and therefore the degree of the given polynomial f(n) is 3.

Theta Notation(θ) is the actual order of the algorithm ==> [θ(n^3)]
Big O Notation(O) is greater than or equal to the order of the algorithm ==> [O(n^3) | O(n^4) | O(n^1000)] 
Omega Notation(Ω) is less than or equal to the order of the algorithm ==> [Ω(n^3) | Ω(n^2) | Ω(n^1)]

The most important of these 3 is the Big O notation because it tells us the upper bound of the algorithm or the worst case.
The actual time of the algorithm will be always less that this.




Order of growth
Constant order < log(log n) < log n < n^-1/2 < n < n log n < n^2 < n^3 <  ........ < 2^n < n^n
Constant order ==> (int n = 2 * 3, where n has no dependency and is equal to 6)

f(n) = n^2log n + n^3 + n^2 + n^-1/2n^3
==> θ(n^-1/2n^3) || O(n^-1/2n^3) | O(n^-1/2n^100) || Ω(n^-1/2n^100) | Ω(1)




Examples:
for(int i=0; i<n; i++){
  //Constant operation
}
for(int j=0; j<m; j++){
  //Constant operation
}
==> O(n+m)


for(int i=0; i<n; i++){
  for(int j=0; j<m; j++){
  //Constant operation
  }
}
==> O(n*m)


for(int i=2; i<n; i=pow(i,c)){
  //Constant operation
}
After each iteration the value of i will be , i = 2, 2^c, (2^c)^c, ............., (2^c)^k, n
Maximum value of i will be :
(2^c)^k < n 
==> log2((2^c)^k) < log2(n)
==> c^k log2(2) < log2(n)
==> c^k < log2(n)
==> logc(c^k) < logc(log2(n))
==> k logc(c) < logc(log2(n))
==> k < logc(log2(n))

Therfore O(logc(log2(n)))


int fibonacci(n){
  if(n <= 1)
    return n;
  }
  return fibonacci(n-1) + fibonacci(n-2);
}

fibonacci(n) = fibonacci(n-1) + fibonacci(n-2) //This is called Reccurence relation
We know that,
fibonacci(n-2) < fibonacci(n-1)

Adding fibonacci(n-1) on both sides :
==> fibonacci(n-2) + fibonacci(n-1) < fibonacci(n-1) + fibonacci(n-1)
==> fiboncacci(n-2) + fibonacci(n-1) < 2fibonacci(n-1)
==> fibonacci(n) < 2fibonacci(n-1)
==> fibonacci(n)/fibonacci(n-1) < 2

Since we derived the above relation, we can write equations as :
fibonacci(n)/fibonacci(n-1) < 2
fibonacci(n-1)/fibonacci(n-2) < 2
fibonacci(n-2)/fibonacci(n-3) < 2
            .
            .
            .
            .
fibonacci(2)/fibonacci(1) < 2
fibonacci(1)/fibonacci(0) < 2


If we multiply all the above equations, we get

fibonacci(n)/fibonacci(0) < 2^n

We know from the algorithm that fibonacci(0) = 0 ==> Constant operation
==> fibonacci(n) < 2^n

Therefore O(2^n)




How to solve patterns?
When a question for pattern comes, we need to remember 3 things:
1) No. of rows(==> How many times the loop should run)
2) No. of columns in the each row(ith row ==> no. of columns)
3) What to print

4444
4444
4444
4444

or

333
333
333
private static void printPattern(int n){
  for(int i=1; i<= n; i++){ //Loop to print row
    for(int j=1; j<=n; j++){ //No. of columns in each row
      System.out.print(n);  //println() will print in each line, hence using print()
    }
    System.out.println();
  }
}

****
****
****
****
or
***
***
***
private static void printPattern(int n){
  for(int i=1; i<= n; i++){ //Loop to print row
    for(int j=1; j<=n; j++){ //No. of columns in each row
      System.out.print("*");  //println() will print in each line, hence using print()
    }
    System.out.println();
  }
}
